# 浏览器安全之 CSRF 攻击

在之前的分享 [《从前端的角度去理解XSS攻击》](https://github.com/moeacg/Learning-notes/issues/4) 中我们简单的了解了一下，什么时候 XSS 攻击，XSS 的攻击方式必须要在浏览器中注入恶意脚本，并且通过执行该恶意脚本来实现 XSS 攻击，XSS 攻击它的破坏性很大，不过除了 XSS 攻击，另外一种类型的攻击也不容小觑，它就是 CSRF 攻击。

## 一、 什么是 CSRF 攻击

CSRF 攻击的全名叫做 **跨站请求伪造（Cross-site request forgery）**，是指用户在访问黑客的网站时，利用用户的登录态去发起跨站请求。

为什么这种跨站请求会被当做是一种攻击手段呢？其实是因为浏览器在第三方网站中发送跨站请求时，会默认携带目标域名的`Cookie`，让服务器误以为是被攻击者自己发送的请求。

当然，CSRF 攻击的所有攻击方式，成功的前提都在于服务器对于用户登录态的校验出现了漏洞，因此 CSRF 攻击是属于服务器的漏洞类型。

## 二、CSRF 攻击有哪些常见的攻击手段？

> CSRF 攻击常见的手段有：GET类型、POST类型、链接类型。

### GET 类型的 CSRF 攻击

先来看看最简单的 `GET` 类型，这种攻击方式只需要一个 `HTTP` 请求即可实现，一般都是通过 `img` 标签使浏览器自动发送请求。

我们假设某个网站的转账接口是`hacker.com/sendcoin`，它可以接受 `GET` 和 `POST` 请求，参数为用户名 `user` 和转账数值 `number` ，这时候我们就可以通过自动发送 `GET` 请求的方式去进行 `CSRF` 攻击了。

```html
<!DOCTYPE html>
<html>
  <body>
    <h1>CSRF攻击演示</h1>
    <img src="https://hacker.com/sendcoin?user=hacker&number=100">
  </body>
</html>
```

上面这段 `HTML` 代码，黑客将转账的请求接口隐藏在 `img` 标签中，让浏览器误以为这是一张图片资源，当页面被加载的时候，浏览器就会自动发起 `img` 的请求，如果此时服务器没有对该请求做校验判断，那么服务器就会认为这是一个转账请求，于是用户账户上的钱就被转移到黑客账户上了。

### POST 类型的 CSRF 攻击

那如果网站的接口，做了一部分安全处理，不允许用户使用 `GET` 请求，只接受 `POST` 请求时，黑客是怎么伪造的呢？

在这里我举个很有名的例子，那就是 2007 年 Gmail 的 CSRF 漏洞：

在 2007 年的某天，Gmail 的用户 David 打开了他邮箱中的一份邮件，并且点击了该邮件中的一个链接，过了不久，David 就发现它名下的域名被转出给了一个他不认识的人，也就是他的域名被盗了。

这个时候问题就来了，他的域名被盗和点击邮件中的链接有没有关联呢？答案是有的：

![1](/assets/005/img/1.png)

首先，David 在查看 Gmail 邮件时，他一定是已经登录的状态，此时浏览器的 `Cookie` 中就会包含他的登录态。然后 David 在邮件中点击链接的时候，进入了黑客的网站，在网站的页面中，黑客已经写好了伪造的邮件过滤请求。通过执行一个隐藏的表单，可以实现自动跨站点的 POST 数据提交。

![2](/assets/005/img/2.png)

并且通过 Gmail 提供的接口，把所有发给 David 的邮件都转发到了黑客的邮箱。

![3](/assets/005/img/3.png)

![4](/assets/005/img/4.png)

最后就很简单明了了，因为有了 David 的邮件内容，黑客通过邮件的方式重置了他在域名服务商那边的账号密码，然后将他的域名转移到了自己的账户上。

如果你想详细了解 David 整个被攻击的过程中，可以通过下面的链接去他的站点上查看，他在要回了他的域名后将整个过程分享到了他的站点上了。

[Warning: Google Gmail security failure](https://www.davidairey.com/google-gmail-security-hijack)

### 链接类型的 CSRF 攻击

除了我们刚才描述的页面自动发起的 `GET` 和 `POST` 请求的攻击方式，`CSRF` 攻击还有一种并不常用的攻击方式，那就是通过用户点击链接的方式去进行攻击，这个时候黑客大多会采用在论坛中发布一些带有恶意链接的图片，或者以广告的形式诱导用户点击，导致用户中招，黑客通常会使用很夸张的词语器诱骗用户点击链接，例如：

```html
 <a href="http://header.com/sendcoin?user=hacker&number=100" taget="_blank">
  震惊！男人看了会沉默，女人看了会流泪！不转不是中国人！
 <a/>
```

以上就是最常用的 `CSRF` 攻击手段，到这里我们可以知道什么是 `CSRF`  攻击了，总结一下就是：

**`CSRF` 攻击并不需要将恶意代码注入到用户的页面中，它仅仅是利用了服务器的漏洞和用户的登录态就可以实现攻击。**

## 三、如何防范 CSRF 攻击？

了解了常见的 `CSRF` 攻击手段后，我们知道，黑客如何想要成功的实现 `CSRF` 攻击，必须要满足三个条件：

- 一、攻击的目标站点一定要有 `CSRF`漏洞
- 二、攻击的目标用户一定要在该站点上登录过，并且保存了登录态。
- 三、需要目标用户打开一个黑客写好攻击代码的第三方站点。

通过这三个条件我们就可以看出来，`CSRF` 攻击和 `XSS` 攻击最大的不同了，`CSRF` 攻击不会再页面中注入恶意代码，所以黑客是没有办法通过 `CSRF` 攻击来获取用户的页面数据，它最关键的是要找到服务器的漏洞，所以对于 `CSRF` 攻击，我们最重要的防护手段是提升服务器的安全性。

为了让服务器避免受到 `CSRF` 攻击，通常有以下几种方法：

### 1. 验证发起请求的来源站点

现在我们知道了，`CSRF` 攻击大多是来自第三方网站的页面，因此服务器可以通过同源检测禁止任何来自第三方站点的请求。

那么这个时候问题来了，我们怎么去判断一个请求它是不是来自第三方站点呢？

其实在 `HTTP` 协议中，每一个异步请求在发起的时候，都会在 `header` 中携带两个参数用于标记发起请求的域名：

它们分别是： `Origin` 和 `Referer`

![5](/assets/005/img/5.png)

`Referer` 是 `HTTP` 请求头当中的一个字段，记录了该请求的来源地址。

虽然我们可以通过 `Referer` 来告诉服务器请求的来源，但是我们可以通过 `W3C` 在2014年发布的 `Referrer Policy` 草案，将`Referer` 值隐藏掉，设置 `Referrer Policy` 的方法有三种：

- 通过 `CSP` 设置
- 在页面的 `head` 中增加 `meta` 标签
- 在 `a` 标签中增加 `referrerpolicy` 属性

既然 `Referer` 可以通过设置被隐藏，那么仅仅只是验证请求头中的 `Referer` 字段并不可靠，因此我们还需要对另外一个字段 `Origin` 字段进行验证，在通过 `XMLHttpRequest` 、`Fecth` 发起跨站请求或者使用 `POST` 方法发送请求时，浏览器都会带上 `Origin` 属性。

和 `Referer` 字段不同，`Origin` 字段只会包含域名的 `Host` 并不会包含具体当然 `Url` 路径，这是它和 `Referer` 字段的一个主要区别。

因此服务器可以优先判断请求的 `header` 中是否包含了 `Origin` 字段，若没有，再根据实际情况判断是否使用 `Referer` 值。

### 2. 使用 Cookie 的 SameSite 属性

通过之前的介绍，我们已经知道了 `CSRF` 攻击是通过利用用户的登录态来伪造请求的，那么 `Cookie`  在其中属于最关键的数据，因此若要阻止 `CSRF` 攻击，我们可以利用 `Cookie` 的 `SameSite` 属性，

`SameSite` 属性通常由 `Strict`、`Lax`、`None` 这三个值，表示三种不同的严格程度。

- `Strict` 是最为严格，如果将 `SameSite` 的值设置为 `Strict` ，那么浏览器就会完全禁止第三方的 `Cookie`，任何时候的跨站请求不会带上 `Cookie` ，除非是同源域名。
- `Lax` 相对宽松一点，在非同源域名下发送的跨站请求，只会在通过第三方站点的链接或者从第三方站点提交 `GET` 请求的表单时才会携带 `Cookie`。
- `None` 在任何情况下都会发送 `Cookie` 数据。

如果你想更加详细的了解 `SameSite` 的使用方式，可以参考文章： [SameSite cookies explained](https://web.dev/samesite-cookies-explained/)

### 3. CSRF Token

`CSRF` 攻击能够成功的最大原因，是因为服务器把攻击者伪造的请求当成了用户自己的请求，那么我们可以要求用户在发送请求时，都带上一个 `CSRF` 攻击者无法获取的 `Token` ，服务器通过校验请求中是否携带了 `Token`，以及携带的 `Token` 是否有效来将正常的请求和伪造的请求区分开，这样也能够对 `CSRF` 攻击进行防范。

## 四、总结

`CSRF` 攻击就是黑客利用用户在某些网站上的登录态，通过第三方的站点去发起伪造的请求。常见的 `CSRF` 攻击方式有 `GET 类型`、`POST 类型`、`链接类型`。

所有的 `CSRF` 攻击能够成功的必要条件是：

1. 目标站点有 `CSRF` 漏洞
2. 用户在目标站点有登录态
3. 用户打开了一个包含恶意代码的第三方站点

针对 `CSRF` 攻击，我们主要的防范机制有三种，第一种是通过验证发起请求的来源站点域名，第二种是使用 `Cookie` 的 `SameSite` 属性来过滤非同源站点请求的 `Cookie` 信息，第三种就是使用 `CSRF Token` 的方式来区分用户正常的请求和伪造的请求。

### 参考链接

1. [前端安全系列（二）：如何防止CSRF攻击？](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)
2. [SameSite cookies explained](https://web.dev/samesite-cookies-explained/)
3. [Warning: Google Gmail security failure](https://www.davidairey.com/google-gmail-security-hijack)
4. [极客时间课程-浏览器工作原理与实践](https://time.geekbang.org/column/intro/100033601)
